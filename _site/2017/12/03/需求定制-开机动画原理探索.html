<h3 id="bootanimtion">一、bootanimtion服务</h3>

<h4 id="initbootanimation">1.1 init阶段bootanimation服务配置</h4>

<p>从Android 7.0开始，谷歌将bootnimation服务从init.rc中分离出来，单独存放在 frameworks/base/cmds/bootanimation/目录下bootanim.rc文件中：
<code class="highlighter-rouge">rc
service bootanim /system/bin/bootanimation
    class core
    user graphics
    group graphics audio
    disabled //init启动时不会启动bootanimation服务
    oneshot
    writepid /dev/stune/top-app/tasks
</code>
bootanimation服务的用户和用户组分别为graphic和graphics audio。需要关注的disabled，即在init启动阶段该服务是不会启动的。oneshot表示该服务只启动一次。</p>

<h4 id="surfaceflingerbootnimation">1.2 surfaceflinger服务调用bootnimation</h4>

<p>当SurfaceFlinger服务启动时，它会通过修改系统属性ctl.start的值来通知init进程启动bootanimation服务。</p>

<p>早期的版本中，SurfaceFlinger服务是在SystemServer服务中启动的；Android 5.0之后变为init.rc脚本中控制其在init阶段启动。Android 7.0之后谷歌又将其独立为surfaceflinger.rc文件，存放在frameworks/native/services/surfaceflinger/目录下：
<code class="highlighter-rouge">rc
service surfaceflinger /system/bin/surfaceflinger
    class core
    user system
    group graphics drmrpc readproc
    onrestart restart zygote
    writepid /dev/stune/foreground/tasks
</code></p>

<p>接下来看看SurfaceFlinger的入口文件main_surfaceflinger.cpp：
<code class="highlighter-rouge">c
int main(int, char**) {
    ......
    sp&lt;SurfaceFlinger&gt; flinger = DisplayUtils::getInstance()-&gt;getSFInstance();
    ......
    // 我们这里只关注init方法
    flinger-&gt;init();
    ......
    // 在该线程中运行surface flinger
    flinger-&gt;run();
    return 0;
}
</code>
main函数主要任务就是：先新建SurfaceFlinger对象，然后调用init方法，接着调用run方法。</p>

<p>在SurfaceFlinger.cpp的init方法中，创建一系列事件线程后，调用startBootAnim方法启动动画。
<code class="highlighter-rouge">c
void SurfaceFlinger::init() {
    ALOGI(  "SurfaceFlinger's main thread ready to run. "
            "Initializing graphics H/W...");
    ......
    // 启动boot animation
    startBootAnim();
    ALOGV("Done initializing");
}
</code>
在startBootAnim函数中，将service.bootanim.exit属性置为0，将ctl.start属性置为bootanim。
<code class="highlighter-rouge">c
void SurfaceFlinger::startBootAnim() {
    // start boot animation
    property_set("service.bootanim.exit", "0");
    property_set("ctl.start", "bootanim");
}
</code></p>

<h4 id="init">1.3 init进程处理属性变化</h4>

<p>下面来看init.cpp的main函数：
<code class="highlighter-rouge">c
int main(int argc, char** argv) {
    ......
    // 启动系统属性服务
    start_property_service();
    ......
    return 0;
}
</code></p>

<p>接着看property_service.cpp的start_property_service方法，调用register_epoll_handler函数监听属性变化。当属性值变化时，调用handle_property_set_fd
<code class="highlighter-rouge">c
void start_property_service() {
    property_set_fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
                                    0666, 0, 0, NULL);
    if (property_set_fd == -1) {
        ERROR("start_property_service socket creation failed: %s\n", strerror(errno));
        exit(1);
    }
    listen(property_set_fd, 8);
    register_epoll_handler(property_set_fd, handle_property_set_fd);
}
</code></p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_property_set_fd</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 通过socket接收系统属性变化事件
</span>    <span class="n">prop_msg</span> <span class="n">msg</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ucred</span> <span class="n">cr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="n">addr</span><span class="p">;</span>
    <span class="n">socklen_t</span> <span class="n">addr_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
    <span class="n">socklen_t</span> <span class="n">cr_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cr</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">source_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pollfd</span> <span class="n">ufds</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">timeout_ms</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
    <span class="c1">// 接收TCP连接
</span>    <span class="k">if</span> <span class="p">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">property_set_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_size</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 取出socket中内容
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">getsockopt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_PEERCRED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="n">ERROR</span><span class="p">(</span><span class="s">"Unable to receive socket options</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ufds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">ufds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">;</span>
    <span class="n">ufds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 轮询客户端事件
</span>    <span class="n">nr</span> <span class="o">=</span> <span class="n">TEMP_FAILURE_RETRY</span><span class="p">(</span><span class="n">poll</span><span class="p">(</span><span class="n">ufds</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">timeout_ms</span><span class="p">));</span>
    <span class="c1">// 轮询事件超时
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ERROR</span><span class="p">(</span><span class="s">"sys_prop: timeout waiting for uid=%d to send property message.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cr</span><span class="p">.</span><span class="n">uid</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="c1">// 等待错误
</span>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ERROR</span><span class="p">(</span><span class="s">"sys_prop: error waiting for uid=%d to send property message: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cr</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="n">close</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 接收socket主体数据
</span>    <span class="n">r</span> <span class="o">=</span> <span class="n">TEMP_FAILURE_RETRY</span><span class="p">(</span><span class="n">recv</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span> <span class="n">MSG_DONTWAIT</span><span class="p">));</span>
    <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prop_msg</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">ERROR</span><span class="p">(</span><span class="s">"sys_prop: mis-match msg size received: %d expected: %zu: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
              <span class="n">r</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prop_msg</span><span class="p">),</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="n">close</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 判断接收条件
</span>    <span class="k">switch</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 系统属性变化
</span>    <span class="k">case</span> <span class="n">PROP_MSG_SETPROP</span><span class="p">:</span>
        <span class="n">msg</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">PROP_NAME_MAX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">msg</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="n">PROP_VALUE_MAX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// 检查属性值是否合法
</span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_legal_property_name</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">name</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">ERROR</span><span class="p">(</span><span class="s">"sys_prop: illegal property name. Got: </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
            <span class="n">close</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">getpeercon</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">source_ctx</span><span class="p">);</span>
        <span class="c1">// 判断是否是ctl开头的属性，是则调用handle_control_message方法
</span>        <span class="k">if</span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="s">"ctl."</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">close</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">check_control_mac_perms</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">source_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">handle_control_message</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">msg</span><span class="p">.</span><span class="n">name</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">msg</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">ERROR</span><span class="p">(</span><span class="s">"sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                        <span class="n">msg</span><span class="p">.</span><span class="n">name</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">cr</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">cr</span><span class="p">.</span><span class="n">gid</span><span class="p">,</span> <span class="n">cr</span><span class="p">.</span><span class="n">pid</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">check_mac_perms</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">source_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">property_set</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">msg</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">msg</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">ERROR</span><span class="p">(</span><span class="s">"sys_prop: permission denied uid:%d  name:%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                      <span class="n">cr</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">close</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">freecon</span><span class="p">(</span><span class="n">source_ctx</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
        <span class="n">close</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>调用handle_control_message方法启动bootanima服务
<code class="highlighter-rouge">c
void handle_control_message(const std::string&amp; msg, const std::string&amp; name) {
    Service* svc = ServiceManager::GetInstance().FindServiceByName(name);
    if (svc == nullptr) {
        ERROR("no such service '%s'\n", name.c_str());
        return;
    }
    if (msg == "start") {
        svc-&gt;Start();
    } else if (msg == "stop") {
        svc-&gt;Stop();
    } else if (msg == "restart") {
        svc-&gt;Restart();
    } else {
        ERROR("unknown control msg '%s'\n", msg.c_str());
    }
}
</code></p>

<h3 id="section">二、 开机动画启动</h3>

<h4 id="section-1">2.1 开机动画显示流程</h4>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">setpriority</span><span class="p">(</span><span class="n">PRIO_PROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ANDROID_PRIORITY_DISPLAY</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">value</span><span class="p">[</span><span class="n">PROPERTY_VALUE_MAX</span><span class="p">];</span>
    <span class="n">property_get</span><span class="p">(</span><span class="s">"debug.sf.nobootanimation"</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="s">"0"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">noBootAnimation</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">ALOGI_IF</span><span class="p">(</span><span class="n">noBootAnimation</span><span class="p">,</span>  <span class="s">"boot animation disabled"</span><span class="p">);</span>
    <span class="c1">// 检查属性debug.sf.nobootanimation是否不等于0
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">noBootAnimation</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 启动一个binder线程池
</span>        <span class="n">sp</span><span class="o">&lt;</span><span class="n">ProcessState</span><span class="o">&gt;</span> <span class="n">proc</span><span class="p">(</span><span class="n">ProcessState</span><span class="o">::</span><span class="n">self</span><span class="p">());</span>
        <span class="n">ProcessState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">startThreadPool</span><span class="p">();</span>
        <span class="c1">// 创建boot animation对象
</span>        <span class="n">sp</span><span class="o">&lt;</span><span class="n">BootAnimation</span><span class="o">&gt;</span> <span class="n">boot</span> <span class="o">=</span> <span class="n">new</span> <span class="n">BootAnimation</span><span class="p">();</span>
        <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">joinThreadPool</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>接下来看看BootAnimation.h中的声明：
<code class="highlighter-rouge">c
class BootAnimation : public Thread, public IBinder::DeathRecipient
{
public:
                BootAnimation();
    virtual     ~BootAnimation();
    sp&lt;SurfaceComposerClient&gt; session() const;
private:
    // 每个线程类都要实现的，这个函数如果返回true，且没有requestExist()没有被调用，则该函数会再次执行；如果返回false，则threadloop中的内容仅仅执行一次，线程就会退出。
    virtual bool        threadLoop();
    // Thread执行前的初始化工作；
    virtual status_t    readyToRun();
    // 属于其父类RefBase，该函数在强引用sp新增引用计数时调用，即有sp包装的类初始化时调用；
    virtual void        onFirstRef();
    // 当对象死了或其他情况导致该Binder结束时，就会回调binderDied()方法;
    virtual void        binderDied(const wp&lt;IBinder&gt;&amp; who);
    ......
    status_t initTexture(Texture* texture, AssetManager&amp; asset, const char* name);
    status_t initTexture(FileMap* map, int* width, int* height);
    status_t initFont(Font* font, const char* fallback);
    // 显示系统默认的开机画面；
    bool android();
    // 显示用户自定义的开机动画。
    bool movie();
    ......
};
</code></p>

<p>接下来看看BootAnimation.cpp中各函数的具体实现：
BootAnimation间接继承自RefBase类，并重写了其onFirstRef方法，所以智能指针第一次调用BootAnimation时即先调用onFirstRef方法。
```c
void BootAnimation::onFirstRef() {
    // 注册SurfaceFlinger服务的死亡接收通知
    status_t err = mSession-&gt;linkToComposerDeath(this);
    ALOGE_IF(err, “linkToComposerDeath failed (%s) “, strerror(-err));
    if (err == NO_ERROR) {
        run(“BootAnimation”, PRIORITY_DISPLAY);
    }
}</p>

<p>BootAnimation::BootAnimation() : Thread(false), mClockEnabled(true), mTimeIsAccurate(false),
        mTimeFormat12Hour(false), mTimeCheckThread(NULL) {
    // 用于同Surfaceflinger进行Binder进程间通信
    mSession = new SurfaceComposerClient();
    mSystemBoot = !property_get_bool(BOOT_COMPLETED_PROP_NAME, 0);
}
```</p>

<p>当onFirstRef调用了父类的run方法后，系统会创建一个新线程，该线程执行前会先调用readyToRun方法执行一系列初始化操作：
```c
status_t BootAnimation::readyToRun() {
    mAssets.addDefaultAssets();
    // 检查显示屏信息
    sp<IBinder> dtoken(SurfaceComposerClient::getBuiltInDisplay(
            ISurfaceComposer::eDisplayIdMain));
    DisplayInfo dinfo;
    status_t status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;dinfo);
    if (status)
        return -1;
    // 获得一个SurfaceControl对象control
    sp<SurfaceControl> control = session()-&gt;createSurface(String8("BootAnimation"),
            dinfo.w, dinfo.h, PIXEL_FORMAT_RGB_565);
    SurfaceComposerClient::openGlobalTransaction();
    control-&gt;setLayer(0x40000000);
    SurfaceComposerClient::closeGlobalTransaction();
    // control的成员函数会返回一个Surface对象
    sp<Surface> s = control-&gt;getSurface();
    // 初始化OPENEGL和EGL
    const EGLint attribs[] = {
            EGL_RED_SIZE,   8,
            EGL_GREEN_SIZE, 8,
            EGL_BLUE_SIZE,  8,
            EGL_DEPTH_SIZE, 0,
            EGL_NONE
    };
    EGLint w, h;
    EGLint numConfigs;
    EGLConfig config;
    EGLSurface surface;
    EGLContext context;
    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
    eglInitialize(display, 0, 0);
    eglChooseConfig(display, attribs, &amp;config, 1, &amp;numConfigs);
    surface = eglCreateWindowSurface(display, config, s.get(), NULL);
    context = eglCreateContext(display, config, NULL, NULL);
    eglQuerySurface(display, surface, EGL_WIDTH, &amp;w);
    eglQuerySurface(display, surface, EGL_HEIGHT, &amp;h);
    if (eglMakeCurrent(display, surface, surface, context) == EGL_FALSE)
        return NO_INIT;
    mDisplay = display;
    mContext = context;
    mSurface = surface;
    mWidth = w;
    mHeight = h;
    mFlingerSurfaceControl = control;
    mFlingerSurface = s;
    // 如果开启加密，则显示加密动画
    char decrypt[PROPERTY_VALUE_MAX];
    property_get("vold.decrypt", decrypt, "");
    bool encryptedAnimation = atoi(decrypt) != 0 || !strcmp("trigger_restart_min_framework", decrypt);
    // 选择对应目录下动画文件
    // 加密动画
    if (encryptedAnimation &amp;&amp; (access(getAnimationFileName(IMG_ENC), R_OK) == 0)) {
        mZipFileName = getAnimationFileName(IMG_ENC);
    }
    // OEM动画
    else if (access(getAnimationFileName(IMG_OEM), R_OK) == 0) {
        mZipFileName = getAnimationFileName(IMG_OEM);
    }
    // 系统动画
    else if (access(getAnimationFileName(IMG_SYS), R_OK) == 0) {
        mZipFileName = getAnimationFileName(IMG_SYS);
    }
    return NO_ERROR;
}</Surface></SurfaceControl></IBinder></p>

<p>const char <em>BootAnimation::getAnimationFileName(ImageID image)
{
    const char *fileName[3] = { OEM_BOOTANIMATION_FILE,
            SYSTEM_BOOTANIMATION_FILE,
            SYSTEM_ENCRYPTED_BOOTANIMATION_FILE };
    if (Environment::isSupported()) {
        Environment</em> environment = new Environment();
        const char* animFile = environment-&gt;getMediaFile(
                Environment::ANIMATION_TYPE, Environment::BOOT_STATUS);
        ALOGE(“Get Carrier Animation type: %d,status:%d”, Environment::ANIMATION_TYPE,Environment::BOOT_STATUS);
        if (animFile != NULL &amp;&amp; strcmp(animFile, “”) != 0) {
           return animFile;
        }else{
           ALOGD(“Get Carrier Animation file: %s failed”, animFile);
        }
        delete environment;
    }else{
           ALOGE(“Get Carrier Animation file,since it’s not support carrier”);
    }</p>

<div class="highlighter-rouge"><pre class="highlight"><code>return fileName[image]; } ```
</code></pre>
</div>

<p>调用threadLoop方法显示动画
<code class="highlighter-rouge">c
bool BootAnimation::threadLoop()
{
    bool r;
    // 判断动画文件是否存在，存在则调用自定义动画，否则调用系统默认动画
    if (mZipFileName.isEmpty()) {
        r = android();
    } else {
        r = movie();
    }
    eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroyContext(mDisplay, mContext);
    eglDestroySurface(mDisplay, mSurface);
    mFlingerSurface.clear();
    mFlingerSurfaceControl.clear();
    eglTerminate(mDisplay);
    IPCThreadState::self()-&gt;stopProcess();
    return r;
}
</code></p>

<h4 id="section-2">2.2 系统默认动画配置</h4>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">bool</span> <span class="n">BootAnimation</span><span class="o">::</span><span class="n">android</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 读取开机动画默认图片frameworks/base/core/res/assets/images
</span>    <span class="c1">// android字样图标
</span>    <span class="n">initTexture</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mAndroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mAssets</span><span class="p">,</span> <span class="s">"images/android-logo-mask.png"</span><span class="p">);</span>
    <span class="c1">// 闪光图片
</span>    <span class="n">initTexture</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mAndroid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mAssets</span><span class="p">,</span> <span class="s">"images/android-logo-shine.png"</span><span class="p">);</span>
    <span class="c1">// 清理屏幕
</span>    <span class="n">glShadeModel</span><span class="p">(</span><span class="n">GL_FLAT</span><span class="p">);</span>
    <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_DITHER</span><span class="p">);</span>
    <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_SCISSOR_TEST</span><span class="p">);</span>
    <span class="n">glClearColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
    <span class="n">eglSwapBuffers</span><span class="p">(</span><span class="n">mDisplay</span><span class="p">,</span> <span class="n">mSurface</span><span class="p">);</span>
    <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
    <span class="n">glTexEnvx</span><span class="p">(</span><span class="n">GL_TEXTURE_ENV</span><span class="p">,</span> <span class="n">GL_TEXTURE_ENV_MODE</span><span class="p">,</span> <span class="n">GL_REPLACE</span><span class="p">);</span>
    <span class="c1">// 动画在屏幕显示位置
</span>    <span class="k">const</span> <span class="n">GLint</span> <span class="n">xc</span> <span class="o">=</span> <span class="p">(</span><span class="n">mWidth</span>  <span class="o">-</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">GLint</span> <span class="n">yc</span> <span class="o">=</span> <span class="p">(</span><span class="n">mHeight</span> <span class="o">-</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">h</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">Rect</span> <span class="n">updateRect</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">xc</span> <span class="o">+</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">w</span><span class="p">,</span> <span class="n">yc</span> <span class="o">+</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">h</span><span class="p">);</span>
    <span class="n">glScissor</span><span class="p">(</span><span class="n">updateRect</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">mHeight</span> <span class="o">-</span> <span class="n">updateRect</span><span class="p">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">updateRect</span><span class="p">.</span><span class="n">width</span><span class="p">(),</span>
            <span class="n">updateRect</span><span class="p">.</span><span class="n">height</span><span class="p">());</span>
    <span class="n">glBlendFunc</span><span class="p">(</span><span class="n">GL_SRC_ALPHA</span><span class="p">,</span> <span class="n">GL_ONE_MINUS_SRC_ALPHA</span><span class="p">);</span>
    <span class="n">glTexEnvx</span><span class="p">(</span><span class="n">GL_TEXTURE_ENV</span><span class="p">,</span> <span class="n">GL_TEXTURE_ENV_MODE</span><span class="p">,</span> <span class="n">GL_REPLACE</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">nsecs_t</span> <span class="n">startTime</span> <span class="o">=</span> <span class="n">systemTime</span><span class="p">();</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">nsecs_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">systemTime</span><span class="p">();</span>
        <span class="kt">double</span> <span class="n">time</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="o">*</span> <span class="kt">float</span><span class="p">(</span><span class="n">time</span> <span class="o">/</span> <span class="n">us2ns</span><span class="p">(</span><span class="mi">16667</span><span class="p">))</span> <span class="o">/</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">;</span>
        <span class="n">GLint</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">floorf</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span> <span class="o">*</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">;</span>
        <span class="n">GLint</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
        <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_SCISSOR_TEST</span><span class="p">);</span>
        <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
        <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_SCISSOR_TEST</span><span class="p">);</span>
        <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
        <span class="c1">// 绘制闪光图片
</span>        <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
        <span class="n">glDrawTexiOES</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>                 <span class="n">yc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">,</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">h</span><span class="p">);</span>
        <span class="n">glDrawTexiOES</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">,</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">h</span><span class="p">);</span>
        <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
        <span class="c1">// 绘制android字样图片
</span>        <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
        <span class="n">glDrawTexiOES</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">w</span><span class="p">,</span> <span class="n">mAndroid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">h</span><span class="p">);</span>
        <span class="n">EGLBoolean</span> <span class="n">res</span> <span class="o">=</span> <span class="n">eglSwapBuffers</span><span class="p">(</span><span class="n">mDisplay</span><span class="p">,</span> <span class="n">mSurface</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">EGL_FALSE</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">nsecs_t</span> <span class="n">sleepTime</span> <span class="o">=</span> <span class="mi">83333</span> <span class="o">-</span> <span class="n">ns2us</span><span class="p">(</span><span class="n">systemTime</span><span class="p">()</span> <span class="o">-</span> <span class="n">now</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sleepTime</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">usleep</span><span class="p">(</span><span class="n">sleepTime</span><span class="p">);</span>
        <span class="c1">// 判断是否退出
</span>        <span class="n">checkExit</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">exitPending</span><span class="p">());</span>
    <span class="n">glDeleteTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mAndroid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
    <span class="n">glDeleteTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mAndroid</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">BootAnimation</span><span class="o">::</span><span class="n">checkExit</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">value</span><span class="p">[</span><span class="n">PROPERTY_VALUE_MAX</span><span class="p">];</span>
    <span class="n">property_get</span><span class="p">(</span><span class="n">EXIT_PROP_NAME</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="s">"0"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">exitnow</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// 判断service.bootanim.exit属性，若为1则请求退出线程
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">exitnow</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">requestExit</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="section-3">2.3 自定义动画配置</h4>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">bool</span> <span class="n">BootAnimation</span><span class="o">::</span><span class="n">movie</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 加载动画文件
</span>    <span class="n">Animation</span><span class="o">*</span> <span class="n">animation</span> <span class="o">=</span> <span class="n">loadAnimation</span><span class="p">(</span><span class="n">mZipFileName</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">animation</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">anyPartHasClock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">animation</span><span class="o">-&gt;</span><span class="n">parts</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">validClock</span><span class="p">(</span><span class="n">animation</span><span class="o">-&gt;</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
            <span class="n">anyPartHasClock</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anyPartHasClock</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mClockEnabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">mUseNpotTextures</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">String8</span> <span class="n">gl_extensions</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">exts</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">glGetString</span><span class="p">(</span><span class="n">GL_EXTENSIONS</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exts</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">glGetError</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">gl_extensions</span><span class="p">.</span><span class="n">setTo</span><span class="p">(</span><span class="n">exts</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">gl_extensions</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"GL_ARB_texture_non_power_of_two"</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">gl_extensions</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"GL_OES_texture_npot"</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">mUseNpotTextures</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">glBlendFunc</span><span class="p">(</span><span class="n">GL_SRC_ALPHA</span><span class="p">,</span> <span class="n">GL_ONE_MINUS_SRC_ALPHA</span><span class="p">);</span>
    <span class="c1">// 清理屏幕
</span>    <span class="n">glShadeModel</span><span class="p">(</span><span class="n">GL_FLAT</span><span class="p">);</span>
    <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_DITHER</span><span class="p">);</span>
    <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_SCISSOR_TEST</span><span class="p">);</span>
    <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
    <span class="n">glTexEnvx</span><span class="p">(</span><span class="n">GL_TEXTURE_ENV</span><span class="p">,</span> <span class="n">GL_TEXTURE_ENV_MODE</span><span class="p">,</span> <span class="n">GL_REPLACE</span><span class="p">);</span>
    <span class="n">glTexParameterx</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_REPEAT</span><span class="p">);</span>
    <span class="n">glTexParameterx</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_REPEAT</span><span class="p">);</span>
    <span class="n">glTexParameterx</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
    <span class="n">glTexParameterx</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
    <span class="n">bool</span> <span class="n">clockFontInitialized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mClockEnabled</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clockFontInitialized</span> <span class="o">=</span>
            <span class="p">(</span><span class="n">initFont</span><span class="p">(</span><span class="o">&amp;</span><span class="n">animation</span><span class="o">-&gt;</span><span class="n">clockFont</span><span class="p">,</span> <span class="n">CLOCK_FONT_ASSET</span><span class="p">)</span> <span class="o">==</span> <span class="n">NO_ERROR</span><span class="p">);</span>
        <span class="n">mClockEnabled</span> <span class="o">=</span> <span class="n">clockFontInitialized</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mClockEnabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">updateIsTimeAccurate</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">mTimeCheckThread</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TimeCheckThread</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
        <span class="n">mTimeCheckThread</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">(</span><span class="s">"BootAnimation::TimeCheckThread"</span><span class="p">,</span> <span class="n">PRIORITY_NORMAL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 播放动画
</span>    <span class="n">playAnimation</span><span class="p">(</span><span class="o">*</span><span class="n">animation</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mTimeCheckThread</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mTimeCheckThread</span><span class="o">-&gt;</span><span class="n">requestExit</span><span class="p">();</span>
        <span class="n">mTimeCheckThread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 释放动画
</span>    <span class="n">releaseAnimation</span><span class="p">(</span><span class="n">animation</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">clockFontInitialized</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">glDeleteTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">animation</span><span class="o">-&gt;</span><span class="n">clockFont</span><span class="p">.</span><span class="n">texture</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>loadAnimation方法加载动画
<code class="highlighter-rouge">c
BootAnimation::Animation* BootAnimation::loadAnimation(const String8&amp; fn)
{
    if (mLoadedFiles.indexOf(fn) &gt;= 0) {
        ALOGE("File \"%s\" is already loaded. Cyclic ref is not allowed",
            fn.string());
        return NULL;
    }
    ZipFileRO *zip = ZipFileRO::open(fn);
    if (zip == NULL) {
        ALOGE("Failed to open animation zip \"%s\": %s",
            fn.string(), strerror(errno));
        return NULL;
    }
    Animation *animation =  new Animation;
    animation-&gt;fileName = fn;
    animation-&gt;zip = zip;
    animation-&gt;clockFont.map = nullptr;
    mLoadedFiles.add(animation-&gt;fileName);
    // 解析动画文件
    parseAnimationDesc(*animation);
    if (!preloadZip(*animation)) {
        return NULL;
    }
    mLoadedFiles.remove(fn);
    return animation;
}
</code></p>

<p>parseAnimationDesc方法解析desc文件,确定动画大小速度等信息。
```c
bool BootAnimation::parseAnimationDesc(Animation&amp; animation)
{
    String8 desString;
    // 读取desc.txt内容
    if (!readFile(animation.zip, “desc.txt”, desString)) {
        return false;
    }
    char const* s = desString.string();
    // 解析desc.txt文件
    for (;;) {
        const char* endl = strstr(s, “\n”);
        if (endl == NULL) break;
        String8 line(s, endl - s);
        const char* l = line.string();
        int fps = 0;
        int width = 0;
        int height = 0;
        int count = 0;
        int pause = 0;
        char path[ANIM_ENTRY_NAME_MAX];
        // 默认黑色
        char color[7] = “000000”;
        char clockPos1[TEXT_POS_LEN_MAX + 1] = “”;
        char clockPos2[TEXT_POS_LEN_MAX + 1] = “”;</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    char pathType;
    if (sscanf(l, "%d %d %d", &amp;width, &amp;height, &amp;fps) == 3) {
        animation.width = width;
        animation.height = height;
        animation.fps = fps;
    } else if (sscanf(l, " %c %d %d %s #%6s %16s %16s",
                      &amp;pathType, &amp;count, &amp;pause, path, color, clockPos1, clockPos2) &gt;= 4) {
        Animation::Part part;
        part.playUntilComplete = pathType == 'c';
        part.count = count;
        part.pause = pause;
        part.path = path;
        part.audioData = NULL;
        part.animation = NULL;
        if (!parseColor(color, part.backgroundColor)) {
            ALOGE("&gt; invalid color '#%s'", color);
            part.backgroundColor[0] = 0.0f;
            part.backgroundColor[1] = 0.0f;
            part.backgroundColor[2] = 0.0f;
        }
        parsePosition(clockPos1, clockPos2, &amp;part.clockPosX, &amp;part.clockPosY);
        animation.parts.add(part);
    }
    else if (strcmp(l, "$SYSTEM") == 0) {
        Animation::Part part;
        part.playUntilComplete = false;
        part.count = 1;
        part.pause = 0;
        part.audioData = NULL;
        part.animation = loadAnimation(String8(SYSTEM_BOOTANIMATION_FILE));
        if (part.animation != NULL)
            animation.parts.add(part);
    }
    s = ++endl;
}
return true; } ```
</code></pre>
</div>

<p>preloadZip处理片段信息
<code class="highlighter-rouge">c
bool BootAnimation::preloadZip(Animation&amp; animation)
{
    // 读取zip文件
    const size_t pcount = animation.parts.size();
    void *cookie = NULL;
    ZipFileRO* zip = animation.zip;
    if (!zip-&gt;startIteration(&amp;cookie)) {
        return false;
    }
    Animation::Part* partWithAudio = NULL;
    ZipEntryRO entry;
    char name[ANIM_ENTRY_NAME_MAX];
    // 循环遍历每个文件
    while ((entry = zip-&gt;nextEntry(cookie)) != NULL) {
        const int foundEntryName = zip-&gt;getEntryFileName(entry, name, ANIM_ENTRY_NAME_MAX);
        if (foundEntryName &gt; ANIM_ENTRY_NAME_MAX || foundEntryName == -1) {
            ALOGE("Error fetching entry file name");
            continue;
        }
        const String8 entryName(name);
        const String8 path(entryName.getPathDir());
        const String8 leaf(entryName.getPathLeaf());
        if (leaf.size() &gt; 0) {
            if (entryName == CLOCK_FONT_ZIP_NAME) {
                FileMap* map = zip-&gt;createEntryFileMap(entry);
                if (map) {
                    animation.clockFont.map = map;
                }
                continue;
            }
            for (size_t j = 0; j &lt; pcount; j++) {
                if (path == animation.parts[j].path) {
                    uint16_t method;
                    // 支持png格式文件
                    if (zip-&gt;getEntryInfo(entry, &amp;method, NULL, NULL, NULL, NULL, NULL)) {
                        if (method == ZipFileRO::kCompressStored) {
                            FileMap* map = zip-&gt;createEntryFileMap(entry);
                            if (map) {
                                Animation::Part&amp; part(animation.parts.editItemAt(j));
                                if (leaf == "audio.wav") {
                                    // 一个片段最多只能包含一个audio文件
                                    part.audioData = (uint8_t *)map-&gt;getDataPtr();
                                    part.audioLength = map-&gt;getDataLength();
                                    partWithAudio = &amp;part;
                                } else if (leaf == "trim.txt") {
                                    part.trimData.setTo((char const*)map-&gt;getDataPtr(),
                                                        map-&gt;getDataLength());
                                } else {
                                    Animation::Frame frame;
                                    frame.name = leaf;
                                    frame.map = map;
                                    frame.trimWidth = animation.width;
                                    frame.trimHeight = animation.height;
                                    frame.trimX = 0;
                                    frame.trimY = 0;
                                    part.frames.add(frame);
                                }
                            }
                        } else {
                            ALOGE("bootanimation.zip is compressed; must be only stored");
                        }
                    }
                }
            }
        }
    }
    // 如果存在trimData，则覆盖默认值
    for (Animation::Part&amp; part : animation.parts) {
        const char* trimDataStr = part.trimData.string();
        for (size_t frameIdx = 0; frameIdx &lt; part.frames.size(); frameIdx++) {
            const char* endl = strstr(trimDataStr, "\n");
            if (endl == NULL) {
                break;
            }
            String8 line(trimDataStr, endl - trimDataStr);
            const char* lineStr = line.string();
            trimDataStr = ++endl;
            int width = 0, height = 0, x = 0, y = 0;
            if (sscanf(lineStr, "%dx%d+%d+%d", &amp;width, &amp;height, &amp;x, &amp;y) == 4) {
                Animation::Frame&amp; frame(part.frames.editItemAt(frameIdx));
                frame.trimWidth = width;
                frame.trimHeight = height;
                frame.trimX = x;
                frame.trimY = y;
            } else {
                ALOGE("Error parsing trim.txt, line: %s", lineStr);
                break;
            }
        }
    }
    // 如果动画文件中有铃声则创建并初始化audioplay
    if (partWithAudio != NULL) {
        ALOGD("found audio.wav, creating playback engine");
        if (!audioplay::create(partWithAudio-&gt;audioData, partWithAudio-&gt;audioLength)) {
            return false;
        }
    }
    zip-&gt;endIteration(cookie);
    return true;
}
</code></p>

<p>playAnimation方法播放动画
```c
bool BootAnimation::playAnimation(const Animation&amp; animation)
{
    const size_t pcount = animation.parts.size();
    nsecs_t frameDuration = s2ns(1) / animation.fps;
    const int animationX = (mWidth - animation.width) / 2;
    const int animationY = (mHeight - animation.height) / 2;
    // 显示每个动画片段
    for (size_t i=0 ; i&lt;pcount ; i++) {
        const Animation::Part&amp; part(animation.parts[i]);
        const size_t fcount = part.frames.size();
        glBindTexture(GL_TEXTURE_2D, 0);
        if (part.animation != NULL) {
            playAnimation(<em>part.animation);
            if (exitPending())
                break;
            continue;
        }
        // 循环显示动画片段
        for (int r=0 ; !part.count || r&lt;part.count ; r++) {
            if(exitPending() &amp;&amp; !part.playUntilComplete)
                break;
            if (r == 0 &amp;&amp; part.audioData &amp;&amp; playSoundsAllowed()) {
                ALOGD(“playing clip for part%d, size=%d”, (int) i, part.audioLength);
                audioplay::playClip(part.audioData, part.audioLength);
            }
            glClearColor(
                    part.backgroundColor[0],
                    part.backgroundColor[1],
                    part.backgroundColor[2],
                    1.0f);
            // 显示每个片段对应的png文件
            for (size_t j=0 ; j&lt;fcount &amp;&amp; (!exitPending() || part.playUntilComplete) ; j++) {
                const Animation::Frame&amp; frame(part.frames[j]);
                nsecs_t lastFrame = systemTime();
                if (r &gt; 0) {
                    glBindTexture(GL_TEXTURE_2D, frame.tid);
                } else {
                    if (part.count != 1) {
                        glGenTextures(1, &amp;frame.tid);
                        glBindTexture(GL_TEXTURE_2D, frame.tid);
                        glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                        glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                    }
                    int w, h;
                    initTexture(frame.map, &amp;w, &amp;h);
                }
                const int xc = animationX + frame.trimX;
                const int yc = animationY + frame.trimY;
                Region clearReg(Rect(mWidth, mHeight));
                clearReg.subtractSelf(Rect(xc, yc, xc+frame.trimWidth, yc+frame.trimHeight));
                if (!clearReg.isEmpty()) {
                    Region::const_iterator head(clearReg.begin());
                    Region::const_iterator tail(clearReg.end());
                    glEnable(GL_SCISSOR_TEST);
                    while (head != tail) {
                        const Rect&amp; r2(</em>head++);
                        glScissor(r2.left, mHeight - r2.bottom, r2.width(), r2.height());
                        glClear(GL_COLOR_BUFFER_BIT);
                    }
                    glDisable(GL_SCISSOR_TEST);
                }
                glDrawTexiOES(xc, mHeight - (yc + frame.trimHeight),
                              0, frame.trimWidth, frame.trimHeight);
                if (mClockEnabled &amp;&amp; mTimeIsAccurate &amp;&amp; validClock(part)) {
                    drawClock(animation.clockFont, part.clockPosX, part.clockPosY);
                }
                eglSwapBuffers(mDisplay, mSurface);
                nsecs_t now = systemTime();
                nsecs_t delay = frameDuration - (now - lastFrame);
                lastFrame = now;
                if (delay &gt; 0) {
                    struct timespec spec;
                    spec.tv_sec  = (now + delay) / 1000000000;
                    spec.tv_nsec = (now + delay) % 1000000000;
                    int err;
                    do {
                        err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;spec, NULL);
                    } while (err&lt;0 &amp;&amp; errno == EINTR);
                }
                checkExit();
            }
            usleep(part.pause * ns2us(frameDuration));
            if(exitPending() &amp;&amp; !part.count)
                break;
        }</p>

<div class="highlighter-rouge"><pre class="highlight"><code>}
for (const Animation::Part&amp; part : animation.parts) {
    if (part.count != 1) {
        const size_t fcount = part.frames.size();
        for (size_t j = 0; j &lt; fcount; j++) {
            const Animation::Frame&amp; frame(part.frames[j]);
            glDeleteTextures(1, &amp;frame.tid);
        }
    }
}
audioplay::setPlaying(false);
audioplay::destroy();
return true; } ```
</code></pre>
</div>

<p>releaseAnimation方法释放动画
<code class="highlighter-rouge">c
void BootAnimation::releaseAnimation(Animation* animation) const
{
    for (Vector&lt;Animation::Part&gt;::iterator it = animation-&gt;parts.begin(),
         e = animation-&gt;parts.end(); it != e; ++it) {
        if (it-&gt;animation)
            releaseAnimation(it-&gt;animation);
    }
    if (animation-&gt;zip)
        delete animation-&gt;zip;
    delete animation;
}
</code></p>

<p>当SystemServer进程中关键服务都起来后，就会将Launcher启动起来，待Launcher启动后会发送idle通知给ActivityManagerService,进而传递给SurfaceFlinger,然后将service.bootanim.exit属性置为0，即退出动画播放。</p>
